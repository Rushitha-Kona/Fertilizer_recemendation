# -*- coding: utf-8 -*-
"""Fertilizer recemendation System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m3T5aiXBzjTjd2voNVrgCLk2clgpstra
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import warnings
warnings.filterwarnings('ignore')

#importing the dataset
data = pd.read_csv('f2.csv')
data.head()

data.info()

#changing the column names
data.rename(columns={'Humidity ':'Humidity','Soil Type':'Soil_Type','Crop Type':'Crop_Type','Fertilizer Name':'Fertilizer'},inplace=True)

#checking unique values
data.nunique()



#checking for null values
data.isna().sum()

data['Potassium'] = data.groupby('Soil_Type')['Potassium'].transform(lambda x: x.replace(0, x.median()))
data['Phosphorous'] = data.groupby('Soil_Type')['Phosphorous'].transform(lambda x: x.replace(0, x.median()))
data['Nitrogen'] = data.groupby('Soil_Type')['Nitrogen'].transform(lambda x: x.replace(0, x.median()))
data.head()

data.to_csv("f2_clean.csv", index=False)

data['Fertilizer'].unique()

data['Crop_Type'].unique()

#statistical parameters
data.describe(include='all')

plt.figure(figsize=(13, 5))
sns.set(style="whitegrid")
sns.countplot(data=data, x='Crop_Type')
plt.title('Count Plot for Crop_Type')
plt.xlabel('Crop_Type')
plt.ylabel('Count')
plt.show()

#first 4 crop types
part1_data = data[data['Crop_Type'].isin(data['Crop_Type'].value_counts().index[:4])]

# Create the first countplot
plt.figure(figsize=(10, 4))
sns.set(style="whitegrid")
sns.countplot(data=part1_data, x='Crop_Type', hue='Fertilizer', width=0.8, palette='Set2')
plt.title('First 4 Crop Types')
plt.xlabel('Crop_Type')
plt.ylabel('Count')
plt.legend(title='Fertilizer')
plt.xticks(rotation=45, horizontalalignment='right')
plt.tight_layout()
plt.show()

from sklearn.preprocessing import LabelEncoder

#encoding Soil Type variable
encode_soil = LabelEncoder()

#fitting the label encoder
data.Soil_Type = encode_soil.fit_transform(data.Soil_Type)

#creating the DataFrame
Soil_Type = pd.DataFrame(zip(encode_soil.classes_,encode_soil.transform(encode_soil.classes_)),columns=['Original','Encoded'])
Soil_Type = Soil_Type.set_index('Original')
Soil_Type

#encoding Crop Type variable
encode_crop = LabelEncoder()

#fitting the label encoder
data.Crop_Type = encode_crop.fit_transform(data.Crop_Type)

#creating the DataFrame
Crop_Type = pd.DataFrame(zip(encode_crop.classes_,encode_crop.transform(encode_crop.classes_)),columns=['Original','Encoded'])
Crop_Type = Crop_Type.set_index('Original')
Crop_Type

#encoding Fertilizer variable
encode_ferti = LabelEncoder()

#fitting the label encoder
data.Fertilizer = encode_ferti.fit_transform(data.Fertilizer)

#creating the DataFrame
Fertilizer = pd.DataFrame(zip(encode_ferti.classes_,encode_ferti.transform(encode_ferti.classes_)),columns=['Original','Encoded'])
Fertilizer = Fertilizer.set_index('Original')
Fertilizer

#splitting the data into train and test
from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(data.drop('Fertilizer',axis=1),data.Fertilizer,test_size=0.2,random_state=1)
print('Shape of Splitting :')
print('x_train = {}, y_train = {}, x_test = {}, y_test = {}'.format(x_train.shape,y_train.shape,x_test.shape,y_test.shape))

x_train.info()

acc = [] # TEST
model = [] #MODEL
acc1=[] # TRAIN

#importing libraries
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import classification_report
from sklearn import metrics
from sklearn import tree
import warnings
warnings.filterwarnings('ignore')

ds = DecisionTreeClassifier(criterion="entropy",random_state=2,max_depth=5)
ds.fit(x_train,y_train)

predicted_values = ds.predict(x_test)
x = metrics.accuracy_score(y_test, predicted_values)
acc.append(x)
model.append('Decision Tree')

# Calculate accuracy for training data
predicted_values_train = ds.predict(x_train) # Changed variable name to avoid conflict
y = metrics.accuracy_score(y_train, predicted_values_train) # Use predicted_values_train
acc1.append(y)

print("DecisionTrees's Accuracy is: ", x*100, y*100)

# Calculate classification report using test data predictions
predicted_values_test = ds.predict(x_test) # Added prediction for test data
print(classification_report(y_test, predicted_values_test)) # Use predicted_values_test

from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import classification_report
NaiveBayes = GaussianNB()

NaiveBayes.fit(x_train,y_train)

predicted_values = NaiveBayes.predict(x_test)
x = metrics.accuracy_score(y_test, predicted_values)
acc.append(x)

predicted_values_train = NaiveBayes.predict(x_train) # Changed variable name to avoid conflict
y = metrics.accuracy_score(y_train, predicted_values_train) # Use predicted_values_train
acc1.append(y)

model.append('Naive Bayes')
print("Naive Bayes's Accuracy is: ", x,y)

predicted_values_test = NaiveBayes.predict(x_test) # Added prediction for test data
print(classification_report(y_test,predicted_values_test)) # Use predicted_values_test

from sklearn.svm import SVC
# data normalization with sklearn
from sklearn.preprocessing import MinMaxScaler
# fit scaler on training data
norm = MinMaxScaler().fit(x_train)
X_train_norm = norm.transform(x_train)
# transform testing dataabs
X_test_norm = norm.transform(x_test)
SVM = SVC(kernel='poly', degree=3, C=1)
SVM.fit(X_train_norm,y_train)

predicted_values = SVM.predict(X_test_norm)
x = metrics.accuracy_score(y_test, predicted_values)
acc.append(x)

predicted_values_train = SVM.predict(X_train_norm)
y = metrics.accuracy_score(y_train, predicted_values_train)
acc1.append(y)

model.append('SVM')
print("SVM's Accuracy is: ", x,y)

predicted_values_test = SVM.predict(X_test_norm)
print(classification_report(y_test,predicted_values_test))

from sklearn.linear_model import LogisticRegression

LogReg = LogisticRegression(random_state=2)

LogReg.fit(x_train,y_train)

predicted_values = LogReg.predict(x_test)
x = metrics.accuracy_score(y_test, predicted_values)
acc.append(x)

predicted_values_train = LogReg.predict(x_train)
y = metrics.accuracy_score(y_train, predicted_values_train)
acc1.append(y)

model.append('Logistic Regression')
print("Logistic Regression's Accuracy is: ", x,y)

predicted_values_test = LogReg.predict(x_test)
print(classification_report(y_test,predicted_values_test))

from sklearn.ensemble import RandomForestClassifier

RF = RandomForestClassifier(n_estimators=200, max_depth=5, random_state=0)
RF.fit(x_train,y_train)

predicted_values = RF.predict(x_test)
x = metrics.accuracy_score(y_test, predicted_values)
acc.append(x)

predicted_values_train = RF.predict(x_train)
y = metrics.accuracy_score(y_train, predicted_values_train)
acc1.append(y)

model.append('RF')
print("RF's Accuracy is: ", x,y)

predicted_values_test = RF.predict(x_test)
print(classification_report(y_test,predicted_values_test))

from sklearn.model_selection import cross_val_score

score = cross_val_score(RF,data,data.Fertilizer,cv=5)
print("Cross-validation score of RF is:",score)
score = cross_val_score(LogReg,data,data.Fertilizer,cv=5)
print("Cross-validation score of LogReg is:",score)
score = cross_val_score(SVM,data,data.Fertilizer,cv=5)
print("Cross-validation score of SVM is:",score)
score = cross_val_score(NaiveBayes,data,data.Fertilizer,cv=5)
print("Cross-validation score of NaiveBayes is:",score)
score = cross_val_score(ds, data, data.Fertilizer,cv=5)
print("Cross-validation score of ds is:",score)

plt.figure(figsize=[10,5],dpi = 100)
plt.title('Accuracy Comparison')
plt.xlabel('Accuracy')
plt.ylabel('Algorithm')
sns.barplot(x = acc,y = model,palette='dark')

#pickling the file
import pickle

# Save the trained model
with open('rf_file.pkl', 'wb') as f:
    pickle.dump(RF, f)

# Save the fitted encoders
with open('soil.pkl', 'wb') as f:
    pickle.dump(encode_soil, f)

with open('crop.pkl', 'wb') as f:
    pickle.dump(encode_crop, f)

with open('fertilizer.pkl', 'wb') as f:
    pickle.dump(encode_ferti, f)

model = pickle.load(open('rf_file.pkl','rb'))
model.predict([[34,67,62,0,1,7,0,30]])

#pickling the file
import pickle
pickle_out = open('fertilizer.pkl','wb')
pickle.dump(encode_ferti,pickle_out)
pickle_out.close()

ferti = pickle.load(open('fertilizer.pkl','rb'))
ferti.classes_[1]

# After label encoding
pickle_out = open('soil.pkl','wb')
pickle.dump(encode_soil, pickle_out)
pickle_out.close()

pickle_out = open('crop.pkl','wb')
pickle.dump(encode_crop, pickle_out)
pickle_out.close()

import pickle

# Load model
model = pickle.load(open('rf_file.pkl', 'rb'))

# Load encoders
soil_enc = pickle.load(open('soil.pkl','rb'))
crop_enc = pickle.load(open('crop.pkl','rb'))
ferti_enc = pickle.load(open('fertilizer.pkl','rb'))

# Example input (before encoding)
soil = "Loamy"
crop = "Wheat"

# Convert categorical inputs into numbers
soil_encoded = soil_enc.transform([soil])[0]
crop_encoded = crop_enc.transform([crop])[0]

# Combine with numeric values (example input shape adjusted)
input_data = [[25, 78, 43, soil_encoded, crop_encoded, 22, 26, 38]]

# Predict
label = model.predict(input_data)[0]

# Convert fertilizer prediction back to original class
fertilizer_name = ferti_enc.classes_[label]

print("Recommended Fertilizer:", fertilizer_name)

